/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package main;

import login.HardCodedCredentialsCallbackHandler;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.keycloak.adapters.jaas.RolePrincipal;

import javax.security.auth.Subject;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.login.LoginContext;
import javax.security.auth.login.LoginException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.*;
import java.security.*;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Collectors;

import static java.nio.file.StandardWatchEventKinds.*;

@Slf4j
public class App {
    private static final String CODE_PROPERTIES = "CODE_PROP_FILE" ;
    private static final String CODE_JARS_PROPERTY = "codeFolder" ;
    private static final int THREAD_POOL_SIZE = 10;

    private final static ClassLoader MAIN_CL = App.class.getClassLoader();



    private static void startWatchingAndProcessing(Path codeJarsLocation, Subject subject, ExecutorService executor) throws IOException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        WatchService watchService = FileSystems.getDefault().newWatchService();
        WatchKey watchKey = codeJarsLocation.register(watchService, ENTRY_CREATE, ENTRY_MODIFY);
        watchKey.reset();
        while (true) {
            List<WatchEvent<?>> watchEvents = watchKey.pollEvents();
            Path lastEventPath = null;
            for (WatchEvent<?> watchEvent : watchEvents) {
                WatchEvent.Kind<?> kind = watchEvent.kind();
                if(kind==OVERFLOW) {
                    LOGGER.warn("OVERFLOW type of event");
                    continue;
                }
                WatchEvent<Path> pathEvent = (WatchEvent<Path>) watchEvent;
                Path filePath = codeJarsLocation.resolve(pathEvent.context());
                LOGGER.info("Path event for file: {}", filePath);
                if(!filePath.equals(lastEventPath)){
                    if (filePath.toFile().getName().endsWith(".jar")) {
                        processJarFile(filePath.toFile(),subject, executor);
                    }
                }
                lastEventPath = filePath;
            }
            if(!watchKey.reset())
                LOGGER.error("Watch key is no longer valid");
        }
    }

    private static void processJarFile(File foundJarFile, Subject subject, ExecutorService executor) throws IOException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        LOGGER.info("Processing jar file: {}", foundJarFile.getName());
        Set<String> foundClasses;
        try {
            JarFile jarFile = new JarFile(foundJarFile);
            foundClasses = getJarClasses(jarFile);
            URL jarUrl = foundJarFile.toURI().toURL();
            for (String foundClass : foundClasses) {
                LOGGER.debug("Checking class: {}",foundClass);
                Subject.doAsPrivileged(subject, new PrivilegedAction<Object>() {
                    @Override
                    public Object run() {
                        try {
                            ClassLoader cl = new URLClassLoader(new URL[]{jarUrl}, MAIN_CL);
                            Class<?> aClass = cl.loadClass(foundClass);
                            submitExecution(aClass, executor);
                        } catch (Exception e) {
                            LOGGER.error("Error processing {}",foundJarFile.getName(),e);
                        }
                        return null;
                    }
                }, AccessController.getContext());
            }
        } catch (Exception e) {
            LOGGER.error("Error processing {}",foundJarFile.getName(),e);
        }
    }

    private static void submitExecution( Class<?> aClass, ExecutorService executor) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        if (Runnable.class.isAssignableFrom(aClass)) {
            LOGGER.debug("Running the runnable class {}",aClass.getCanonicalName());
            Constructor<?> constructor = aClass.getConstructor();
            Runnable task = (Runnable) constructor.newInstance();
            executor.submit(task);
        }else if(Callable.class.isAssignableFrom(aClass)){
            LOGGER.debug("Running a priviledged action from class {}",aClass.getCanonicalName());
            Constructor<?> constructor = aClass.getConstructor();
            Callable task = (Callable) constructor.newInstance();
            executor.submit(task);
        }
    }

    private static Set<String> getJarClasses(JarFile jarFile) {
        Set<String> foundClasses;
        foundClasses = jarFile.stream()
                .map(JarEntry::getRealName)
                .filter(className -> className.endsWith(".class"))
                .map(className -> className.replace("/","."))
                .map(className -> className.substring(0,className.length()-6))
                .collect(Collectors.toSet());
        return foundClasses;
    }


    private static File[] getJars(Path codeJarsLocation) {
        return codeJarsLocation.toFile().listFiles((dir, name) -> name.endsWith(".jar"));
    }

    private static Path getJarsPath() throws IOException {
        String propertiesFileLocation =
                System.getProperty(CODE_PROPERTIES, "code.properties");
        Properties properties = new Properties();
        LOGGER.info("Processing properties file: {}",propertiesFileLocation);
        @NonNull InputStream propertiesAsInputStream = App.class.getClassLoader().getResourceAsStream(propertiesFileLocation);
        properties.load(propertiesAsInputStream);

        String codeJarsLocation = properties.getProperty(CODE_JARS_PROPERTY);
        LOGGER.info("codeJarsLocation: {}", codeJarsLocation);
        return Paths.get(codeJarsLocation);
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException, LoginException {

        CallbackHandler callbackHandler = new HardCodedCredentialsCallbackHandler();

        LoginContext loginContext = new LoginContext("Keycloak",callbackHandler);
        loginContext.login();
        Subject subject = loginContext.getSubject();

        ThreadFactory threadFactory = Subject.doAsPrivileged(subject, new PrivilegedAction<ThreadFactory>() {
            @Override
            public ThreadFactory run() {
                ThreadFactory tf = Executors.privilegedThreadFactory();
                return tf;
            }
        }, null);

        ExecutorService executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE, threadFactory);

        Path codeJarsLocation = getJarsPath();


        if(!codeJarsLocation.toFile().exists()){
            LOGGER.error("Code jars location {} does not exists",codeJarsLocation);
            System.exit(1);
        }
        File[] foundJarFiles = getJars(codeJarsLocation);

        for (File foundJarFile : foundJarFiles) {
            LOGGER.info("Processing intially found jar: {}",foundJarFile.getName());
            try {
                processJarFile(foundJarFile, subject, executor);
            } catch (IOException | ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e ) {
                LOGGER.error("processing jar issue", e);
            }
        }

        try {
            startWatchingAndProcessing(codeJarsLocation, subject, executor);
        } catch (Exception e) {
            LOGGER.error("error jar processing",e);
        }
    }

}
